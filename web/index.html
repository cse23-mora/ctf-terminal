<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sangeeth's Secure Terminal</title>
    <style>
        :root {
            --bg-color: #0c0c0c;
            --text-color: #00ff41;
            --prompt-color: #ff0055;
        }
        body { background: var(--bg-color); color: var(--text-color); font-family: 'Courier New', monospace; padding: 20px; line-height: 1.4; transition: background 0.3s, color 0.3s; }
        #output { white-space: pre-wrap; margin-bottom: 10px; }
        #input-line { display: flex; }
        #prompt { color: var(--prompt-color); margin-right: 10px; font-weight: bold; }
        input { background: transparent; border: none; color: inherit; outline: none; flex: 1; font-family: inherit; font-size: inherit; }
        .boot-line { color: var(--text-color); font-size: 0.85em; }
        .ok { color: var(--bg-color); background: var(--text-color); padding: 0 4px; font-weight: bold; margin-right: 5px; }
    </style>
</head>
<body>

    <div id="output"></div>
    <div id="input-line" style="display: none;">
        <span id="prompt">sangeeth@portfolio:~$</span>
        <input type="text" id="cmd" autofocus spellcheck="false" autocomplete="off">
    </div>

    <script type="module">
        import init, { run_command } from "../secure_terminal/pkg/secure_terminal.js";

        let history = [];
        let historyIndex = -1;

        const themes = {
            matrix: { bg: "#0c0c0c", text: "#00ff41", prompt: "#ff0055" },
            sunset: { bg: "#2d1b2e", text: "#ff9e64", prompt: "#b392f0" },
            dracula: { bg: "#282a36", text: "#f8f8f2", prompt: "#ff79c6" },
            light: { bg: "#ffffff", text: "#333333", prompt: "#005cc5" }
        };

        function setTheme(name) {
            const theme = themes[name];
            if (theme) {
                document.documentElement.style.setProperty('--bg-color', theme.bg);
                document.documentElement.style.setProperty('--text-color', theme.text);
                document.documentElement.style.setProperty('--prompt-color', theme.prompt);
                return `Theme changed to ${name}`;
            }
            return `Theme '${name}' not found. Available: ${Object.keys(themes).join(", ")}`;
        }

        function escapeHtml(text) {
            return text
                .replaceAll("&", "&amp;")
                .replaceAll("<", "&lt;")
                .replaceAll(">", "&gt;");
        }

        function base64_decode(str) {
            const TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            const bytes = [];
            
            for (let i = 0; i < str.length; i += 4) {
                const b1 = TABLE.indexOf(str[i]);
                const b2 = TABLE.indexOf(str[i + 1]);
                const b3 = str[i + 2] === '=' ? 0 : TABLE.indexOf(str[i + 2]);
                const b4 = str[i + 3] === '=' ? 0 : TABLE.indexOf(str[i + 3]);
                
                const n = ((b1 << 18) | (b2 << 12) | (b3 << 6) | b4);
                
                bytes.push((n >> 16) & 0xFF);
                if (str[i + 2] !== '=') bytes.push((n >> 8) & 0xFF);
                if (str[i + 3] !== '=') bytes.push(n & 0xFF);
            }
            
            return new Uint8Array(bytes);
        }

        function triggerDownload(filename, data) {
            const blob = new Blob([data], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function openInNewTab(rawUrl) {
            if (!rawUrl || rawUrl.trim() === "") {
                return "Usage: newtab <url>";
            }

            let normalized = rawUrl.trim();
            if (!/^[a-zA-Z][a-zA-Z\d+.-]*:/.test(normalized)) {
                normalized = `https://${normalized}`;
            }

            let parsed;
            try {
                parsed = new URL(normalized);
            } catch {
                return `newtab: invalid URL '${rawUrl}'`;
            }

            if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
                return "newtab: only http/https URLs are allowed";
            }

            const opened = window.open(parsed.toString(), "_blank", "noopener,noreferrer");
            if (!opened) {
                return "newtab: popup blocked by browser. Allow popups for this site.";
            }

            return `Opened new tab: ${parsed.toString()}`;
        }

        function getAvailableCompletions(input) {
            const commands = ["ls", "cd", "pwd", "cat", "mkdir", "touch", "rm", "date", "echo", "whoami", "downld", "clear", "theme", "history", "newtab"];
            const parts = input.trim().split(" ");
            
            // If we're completing a command (first word)
            if (parts.length === 1) {
                const prefix = parts[0];
                return commands.filter(cmd => cmd.startsWith(prefix));
            }
            
            // If we're completing a filename (second word or later)
            const prefix = parts[parts.length - 1];
            const lsResult = run_command("__ls__");
            const files = lsResult.split(/\s+/).filter(f => f.trim() !== "");
            return files.filter(f => f.startsWith(prefix));
        }

        function autocomplete(input, completions) {
            if (completions.length === 0) return input;
            if (completions.length === 1) {
                const parts = input.trim().split(" ");
                parts[parts.length - 1] = completions[0];
                return parts.join(" ");
            }
            // Multiple matches - show them
            return input;
        }

        async function start() {
            const output = document.getElementById("output");
            const inputLine = document.getElementById("input-line");
            const input = document.getElementById("cmd");
            const prompt = document.getElementById("prompt");

            let waitingForPassword = false; // Track password prompt state

            // 1. Boot Animation
            const bootLines = [
                "[ OK ] Initializing WASM Kernel...",
                "[ OK ] Mounting Virtual Filesystem...",
                "[ OK ] Decrypting Secure Blocks...",
                "[ OK ] User Session: sangeeth_guest verified.",
                "Welcome to Sangeeth-OS v2.0.0 (Updated)\nType 'help' to begin.\n"
            ];

            for (const line of bootLines) {
                const div = document.createElement("div");
                div.className = "boot-line";
                div.innerHTML = line.replace("[ OK ]", '<span class="ok"> OK </span>');
                output.appendChild(div);
                await new Promise(r => setTimeout(r, 300));
            }

            // 2. Initialize WASM
            await init(); 
            inputLine.style.display = "flex";
            input.focus();

            input.addEventListener("keydown", (e) => {
                // Handle Tab for autocomplete
                if (e.key === "Tab") {
                    e.preventDefault();
                    const completions = getAvailableCompletions(input.value);
                    
                    if (completions.length === 1) {
                        // Auto-complete if only one match
                        input.value = autocomplete(input.value, completions);
                        if (!input.value.endsWith(" ") && !input.value.endsWith("/")) {
                            input.value += " ";
                        }
                    } else if (completions.length > 1) {
                        // Show available completions
                        output.innerHTML += `<div style="color: #ffaa00;">Completions: ${escapeHtml(completions.join("   "))}</div>`;
                        window.scrollTo(0, document.body.scrollHeight);
                    }
                    return;
                }

                // Handle Enter
                if (e.key === "Enter") {
                    const val = input.value;

                    // Handle password input (when waiting for password)
                    if (waitingForPassword) {
                        // Send password to backend (without echoing it or adding to history)
                        const result = run_command(val);
                        
                        if (result === "[sudo] Sorry, try again.") {
                            // Password was rejected, ask again
                            output.innerHTML += `<div style="color:#ff0055;">Sorry, try again.</div>`;
                            output.innerHTML += `<div style="color:var(--prompt-color);">[sudo] password: </div>`;
                            waitingForPassword = true;
                        } else if (result.startsWith("DOWNLOAD:")) {
                            // Download command executed after sudo
                            waitingForPassword = false;
                            const currentDir = run_command("__pwd__");
                            const parts = result.split(":");
                            const filename = parts[1];
                            const b64Content = parts.slice(2).join(":");
                            const binaryData = base64_decode(b64Content);
                            
                            output.innerHTML += `<div style="color: #00ff41;">✓ Downloading: ${filename}</div><br>`;
                            triggerDownload(filename, binaryData);
                            prompt.innerText = `sangeeth@portfolio:${currentDir}$`;
                        } else if (result.startsWith("NEWTAB:")) {
                            waitingForPassword = false;
                            const currentDir = run_command("__pwd__");
                            const openMessage = openInNewTab(result.slice("NEWTAB:".length));
                            output.innerHTML += `<div>${escapeHtml(openMessage)}</div><br>`;
                            prompt.innerText = `sangeeth@portfolio:${currentDir}$`;
                        } else if (result.startsWith("THEME:")) {
                            waitingForPassword = false;
                            const currentDir = run_command("__pwd__");
                            const themeName = result.slice("THEME:".length);
                            const themeMessage = setTheme(themeName);
                            output.innerHTML += `<div>${escapeHtml(themeMessage)}</div><br>`;
                            prompt.innerText = `sangeeth@portfolio:${currentDir}$`;
                        } else {
                            // Command executed successfully or returned result
                            waitingForPassword = false;
                            const currentDir = run_command("__pwd__");
                            if (result !== "" && result !== "[sudo] authenticated successfully") {
                                output.innerHTML += `<div>${escapeHtml(result)}</div><br>`;
                            } else if (result === "[sudo] authenticated successfully") {
                                // Silently authenticate, don't show message
                            }
                            prompt.innerText = `sangeeth@portfolio:${currentDir}$`;
                        }
                        
                        input.value = "";
                        window.scrollTo(0, document.body.scrollHeight);
                        input.focus();
                        return;
                    }

                    // For regular commands, add to history
                    if (val.trim() !== "") history.push(val);
                    historyIndex = history.length;

                    let result = run_command(val);

                    const currentDir = run_command("__pwd__"); // Ask Rust for current path

                    if (result === "CLEARED") {
                        output.innerHTML = "";
                    } else if (result.startsWith("[sudo] password:")) {
                        // Password prompt - wait for next input
                        waitingForPassword = true;
                        output.innerHTML += `<div><span style="color:var(--prompt-color)">sangeeth@portfolio:${currentDir}$</span> ${escapeHtml(val)}</div>`;
                        output.innerHTML += `<div style="color:var(--prompt-color);">${escapeHtml(result)}</div>`;
                        input.value = "";
                        prompt.innerText = ""; // Hide the prompt while waiting for password
                        window.scrollTo(0, document.body.scrollHeight);
                        input.focus();
                        return;
                    } else if (result.startsWith("DOWNLOAD:")) {
                        // Handle download command
                        const parts = result.split(":");
                        const filename = parts[1];
                        const b64Content = parts.slice(2).join(":");
                        const binaryData = base64_decode(b64Content);
                        
                        output.innerHTML += `<div><span style="color:var(--prompt-color)">sangeeth@portfolio:${currentDir}$</span> ${escapeHtml(val)}</div>`;
                        output.innerHTML += `<div style="color: #00ff41;">✓ Downloading: ${filename}</div><br>`;
                        
                        triggerDownload(filename, binaryData);
                    } else if (result.startsWith("NEWTAB:")) {
                        const openMessage = openInNewTab(result.slice("NEWTAB:".length));
                        output.innerHTML += `<div><span style="color:var(--prompt-color)">sangeeth@portfolio:${currentDir}$</span> ${escapeHtml(val)}</div>`;
                        output.innerHTML += `<div>${escapeHtml(openMessage)}</div><br>`;
                    } else if (result.startsWith("THEME:")) {
                        const themeName = result.slice("THEME:".length);
                        const themeMessage = setTheme(themeName);
                        output.innerHTML += `<div><span style="color:var(--prompt-color)">sangeeth@portfolio:${currentDir}$</span> ${escapeHtml(val)}</div>`;
                        output.innerHTML += `<div>${escapeHtml(themeMessage)}</div><br>`;
                    } else {
                        output.innerHTML += `<div><span style="color:var(--prompt-color)">sangeeth@portfolio:${currentDir}$</span> ${escapeHtml(val)}</div>`;
                        output.innerHTML += `<div>${escapeHtml(result)}</div><br>`;
                    }
                    
                    // Update the visual prompt for the NEXT line
                    prompt.innerText = `sangeeth@portfolio:${currentDir}$`;
                    input.value = "";
                    window.scrollTo(0, document.body.scrollHeight);
                }


                // Handle Up Arrow (History)
                if (e.key === "ArrowUp") {
                    if (historyIndex > 0) {
                        historyIndex--;
                        input.value = history[historyIndex];
                    }
                    e.preventDefault();
                }

                // Handle Down Arrow (History)
                if (e.key === "ArrowDown") {
                    if (historyIndex < history.length - 1) {
                        historyIndex++;
                        input.value = history[historyIndex];
                    } else {
                        historyIndex = history.length;
                        input.value = "";
                    }
                    e.preventDefault();
                }
            });
        }
        start();
    </script>
</body>
</html>
